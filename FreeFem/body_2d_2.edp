// Matteo Limberto
// 10-9-15
//
// Test 2
//
// Now we use varf to build the matrices and vectors
//
// The zero mean condition is enforced using a Lagrange multiplier
// Stability issues need to be investigated

load "iovtk"
load "Element_P3"

/////////////////////////////
///////  PARAMETERS  ////////
/////////////////////////////

// Define the geometry coefficients : a simplified 2D heart-torso model

real bodyC = 2.0 ; // Eccentricity of the torso
real bodyR = 2.0 ; // Radius of the torso

real heartC = 1.5 ; // heart eccentricity
real heartR = 1.0 ; // heart radius

real ventD = 0.6; // distance of ventricle center from axis
real ventC = 1.0; // ventricle eccentricity
real ventR = 0.25; // ventricle radius

// Physical parameters

real Mi = 3.0 ; // healthy internal conductivity 
real Me = 2.0 ; // healthy external conductivity

real tMi = 1.0 ; // ischemic internal conductivity 
real tMe = 1.0 ; // ischemic external conductivity

real M0 = 1.0 ; // torso conductivity

real tau = 0.3 ; // sharpness of ischemia

real ischVtrans = -60 ; // trans-membrane potentials during resting phase
real healthyVtrans = -90;



// Ischemia location

real ischX = 0.0 ; // x
real ischY = 0.4 ; // y
real ischR = 0.4 ; // R
real ischC = 1.0 ; // eccentricity


/////////////////////////////
///////  PROBLEM    /////////
/////////////////////////////

// Build the mesh

int dH = 0;
int dT = 1;

border body(t = 0 , 2*pi ) {x = bodyR*bodyC*cos(t) ; y = bodyR*sin(t) ; label = dT ;} ; 
border heart(t = 0 , 2*pi ) {x = heartR*heartC*cos(t) ; y = heartR*sin(t) ; label = dH ;} ; 
border lvent(t = 0 , 2*pi ) {x = ventR*ventC*cos(t) - ventD ; y = ventR*sin(t) ; label = dH ;} ;
border rvent(t = 0 , 2*pi ) {x = ventR*ventC*cos(t) + ventD ; y = ventR*sin(t) ; label = dH ;} ;


mesh Th = buildmesh(body(100) + heart(200) + lvent(-40) + rvent(-40) ) ;

	// plot(body(40) + heart(30) + lvent(-10) + rvent(-10) ,wait=1);
	plot(Th, wait=1);


// Finite element spaces

fespace Ph(Th,P0);
fespace Vh(Th,P1);
fespace V2h(Th,P1);


// Get information on regions 
Ph reg = region ;
	// plot(reg, fill = 1 , wait = 1, value = 1);

int regH = reg(0,0);
int regT = reg(0,heartR*1.01);
	// cout << regH << endl;
	// cout << regT << endl;

// Create level-set for ischemia (possibly a signed distance function )

// V2h LS = sqrt ( ischC*(x-ischX)*(x-ischX) + (y-ischY)*(y-ischY) ) - ischR ; 
V2h LS = x ; 

V2h ischRegion = (LS(x,y) <= 0)*(reg == regH) ;

	// plot(Th,LS,wait=1,nbiso=50,value = 1,fill=1);
	plot(Th,ischRegion,wait=1,nbiso=3,value = 1,fill=1, cmm = "Infarcted region location");


// Compute the transmembrane potential (source term)

V2h G = (LS > tau) + 0.5 *(1 + LS/tau + sin(pi*LS/tau)/pi)*(abs(LS) < tau);
V2h vtrans = ischVtrans*(1-G) + healthyVtrans*G ;

	// plot(Th,vtrans,wait=1,nbiso=5,value = 1,fill=1); 

// Test mesh adaptation

 // plot(Th,wait=1);
 // Th = adaptmesh(Th,vtrans) ;
 // plot(Th,wait=1);

// Build the conductivity tensor functions

V2h Mlhs = (Mi + Me )*G*(reg == regH) + (tMi + tMe )*(1-G)*(reg == regH) + M0*(reg == regT) ;
V2h Mrhs = Mi*G*(reg == regH) + tMi*(1-G)*(reg == regH) ;
	plot(Mlhs, fill = 1 , wait = 1, value = 1 , nbiso = 20, cmm = "M lhs", dim = 3 );
	plot(Mrhs, fill = 1 , wait = 1, value = 1 , nbiso = 20, cmm = "M rhs", dim = 3 );


// Setup the forward problem : variational formulations

varf a(uh,tuh) = int2d(Th)(Mlhs*(dx(uh)*dx(tuh) + dy(uh)*dy(tuh))) ;

varf b(uh,tuh) = - int2d(Th)(Mrhs*( dx(tuh)*dx(vtrans) + dy(tuh)*dy(vtrans) ) ) ;

varf c(uh,tuh) = int2d(Th)(tuh) ;

// Setup the forward problem : matrices

matrix A = a(V2h,V2h) ;

real[int] C = c(0,V2h) ;

real[int] B = b(0,V2h) ;

matrix TOTAL = [ [ A ,  C ] ,
				 [ C' , 0 ] ];

set(TOTAL, solver = UMFPACK) ;

// Solve the problem

Vh uh,tuh;

real[int] rhs = [B,0];

cout <<"ndof : " << V2h.ndof << endl;
cout <<"size of rhs : " << rhs.n << endl;

real[int] sol(V2h.ndof + 1);

cout <<"size of solution : " << sol.n << endl;

sol= TOTAL^-1*rhs ;   // COMPLETAMENTE INSTABILE CON I P2 E P1b, MA STABILE CON P1!!!

uh[] = sol(0 : V2h.ndof);

cout << "Lagrange multiplier : " << sol[V2h.ndof] << endl;

// Vh uh,tuh ;
problem ECGforward(uh,tuh) = 
	int2d(Th)(Mlhs*(dx(uh)*dx(tuh) + dy(uh)*dy(tuh)))
	+ int2d(Th)(Mrhs*( dx(tuh)*dx(vtrans) + dy(tuh)*dy(vtrans) ) )
	+ int2d(Th)(1e-8*uh*tuh)
	// + int2d(Th)(uh)*int2d(Th)(tuh) 
	;
// ECGforward;

// Vh aux = dx(vtrans);
// plot(aux,wait=1);
// aux = dy(vtrans);
// plot(aux,wait=1);



//Vh out = uh - int2d(Th)(uh) ;

plot(uh,wait=1,fill=1,nbiso = 20,dim=2);
plot(uh,wait=1,fill=1,nbiso = 20,dim=3);

cout << "At heart boundary : " << int1d(Th,dH)(uh) << endl ;
cout << "At torso boundary : " << int1d(Th,dT)(uh) << endl ;

real integral = int2d(Th)(uh) ; 

cout <<"int(Th)(uh) : " << integral << endl;


 savevtk("forwardECG.vtk",Th,uh) ;

