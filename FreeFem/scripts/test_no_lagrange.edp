////////////////////////////////////////
//////////     PARAMETERS     //////////
////////////////////////////////////////

// load "Element_P3"

// Include mesh and geometrical/physiological parameters
include "body_parameters.edp"

////////////////////////////////////////
//////     FUNCTIONAL SETTING     //////
////////////////////////////////////////

// Finite element spaces
fespace V2h(Th,P1); // P1,P2,P3...

// variational formulations
V2h Mlhs,Mrhs,vtrans;

varf a(uh,tuh) = int2d(Th)(Mlhs*(dx(uh)*dx(tuh) + dy(uh)*dy(tuh))) ;
varf b(uh,tuh) = - int2d(Th)(Mrhs*( dx(tuh)*dx(vtrans) + dy(tuh)*dy(vtrans) ) ) ;
varf c(uh,tuh) = int2d(Th)(tuh) ; // use to enforce the zero-mean condition with a Lagrange multiplier

////////////////////////////////////////
//////      REGION FUNCTION      ///////
////////////////////////////////////////

// Patch the region function to account for the internal boundary
V2h reg = region ;
	 // plot(reg, fill = 1 , wait = 1, value = 1);

int regH = reg(0,0); cout << "regH : " << regH << endl;
int regT = reg(0,heartR*1.01); cout << "regT : " << regT << endl;

varf bd(u,v) = int2d(Th)(u*v) + on(dH , u = 1.) ;
real[int] Bd = bd(0,V2h) ;
reg[] = Bd ? regH : reg[] ;


////////////////////////////////////////
///     SOLVE FOR TARGET SOLUTION    ///
////////////////////////////////////////

cout << "Solving the forward problem for a known ischemia" << endl;

// Define an ischemia 

V2h LS = x ; // level set for the ischemic region
V2h ischRegion = (LS(x,y) <= 0)*(reg == regH) ;
	plot(ischRegion,wait=1,nbiso=4,value = 1,fill=1, cmm = "Infarcted region location");

// Compute the transmembrane potential (source term)
V2h G = (LS > tau) + 0.5 *(1 + LS/tau + sin(pi*LS/tau)/pi)*(abs(LS) < tau);
	// V2h targetW =  1. - G ;
	// plot(targetW,wait=1,value = 1,fill=1, cmm = "Smoothed region function");

vtrans = ischVtrans*(1-G) + healthyVtrans*G ;
	// V2h gvtrans = sqrt( dx(vtrans)*dx(vtrans) + dy(vtrans)*dy(vtrans)) ;
	// plot(gvtrans,wait=1,value = 1,fill=1, cmm = "Gradient of the transmembrane potential");


Mlhs = (Mi + Me )*G*(reg == regH) + (tMi + tMe )*(1-G)*(reg == regH) + M0*(reg == regT) ;
Mrhs = Mi*G*(reg == regH) + tMi*(1-G)*(reg == regH) ;
	// plot(Mlhs, fill = 1 , wait = 1, value = 1 , nbiso = 20, cmm = "M lhs", dim = 2 );
	// plot(Mrhs, fill = 1 , wait = 1, value = 1 , nbiso = 20, cmm = "M rhs", dim = 2 );

// Build the matrices and solve the problem
matrix A = a(V2h,V2h , solver = UMFPACK) ;
real[int] C = c(0,V2h) ;

real[int] B = b(0,V2h) ;
real[int] rhs = [B,0];

matrix TOTAL = [ [ A ,  C ] ,
				 [ C' , 0 ] ];

set(TOTAL, solver = UMFPACK) ;

real[int] sol(V2h.ndof + 1);
sol= TOTAL^-1*rhs ; 

V2h zd;
zd[] = sol(0 : V2h.ndof);
	plot(zd,wait=1,fill=1,nbiso = 20,dim=2 , cmm = "Target solution");

cout << "Lagrange multiplier : " << sol[V2h.ndof] << endl;
cout << "Mean value of solution zd : " << int2d(Th)(zd) / int2d(Th)(1.0) << endl;

// Let us now solve the same problem without Lagrange multipliers

V2h unl ; 
unl[] = A^-1 * B ;

real umean  = int2d(Th)(unl)/int2d(Th)(1.);
unl = unl - umean ;
	plot(unl,wait=1,fill=1,nbiso = 20,dim=2 , cmm = "Target solution : no lagrange multiplier");

V2h error = abs(unl - zd) ; 
	plot(error,wait=1,fill=1,nbiso = 20,dim=2 , cmm = "Error");





