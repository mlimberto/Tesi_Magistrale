// Matteo Limberto
// 10-9-15
//
// Test 2 : we stop using the level set and add some control
//
// Now we use varf to build the matrices and vectors
//
// The zero mean condition is enforced using a Lagrange multiplier
// Stability issues need to be investigated

load "iovtk"

/////////////////////////////
///////  PARAMETERS  ////////
/////////////////////////////

// Define the geometry coefficients : a simplified 2D heart-torso model

real bodyC = 2.0 ; // Eccentricity of the torso
real bodyR = 2.0 ; // Radius of the torso

real heartC = 1.5 ; // heart eccentricity
real heartR = 1.0 ; // heart radius

real ventD = 0.6; // distance of ventricle center from axis
real ventC = 1.0; // ventricle eccentricity
real ventR = 0.25; // ventricle radius

// Physical parameters

real Mi = 3.0 ; // healthy internal conductivity 
real Me = 2.0 ; // healthy external conductivity

real tMi = 1.0 ; // ischemic internal conductivity 
real tMe = 1.0 ; // ischemic external conductivity

real M0 = 1.0 ; // torso conductivity

real tau = 0.3 ; // sharpness of ischemia

real ischVtrans = -60 ; // trans-membrane potentials during resting phase
real healthyVtrans = -90;



// Ischemia location

real ischX = 0.0 ; // x
real ischY = 0.4 ; // y
real ischR = 0.4 ; // R
real ischC = 1.0 ; // eccentricity


/////////////////////////////
///////  PROBLEM    /////////
/////////////////////////////

// Build the mesh

int dH = 0;
int dT = 1;

border body(t = 0 , 2*pi ) {x = bodyR*bodyC*cos(t) ; y = bodyR*sin(t) ; label = dT ;} ; 
border heart(t = 0 , 2*pi ) {x = heartR*heartC*cos(t) ; y = heartR*sin(t) ; label = dH ;} ; 
border lvent(t = 0 , 2*pi ) {x = ventR*ventC*cos(t) - ventD ; y = ventR*sin(t) ; label = dH ;} ;
border rvent(t = 0 , 2*pi ) {x = ventR*ventC*cos(t) + ventD ; y = ventR*sin(t) ; label = dH ;} ;


mesh Th = buildmesh(body(100) + heart(200) + lvent(-40) + rvent(-40) ) ;

	// plot(body(40) + heart(30) + lvent(-10) + rvent(-10) ,wait=1);
	plot(Th, wait=1);


// Finite element spaces

fespace Ph(Th,P0);
fespace Vh(Th,P1);
fespace V2h(Th,P1);


// Get information on regions 
Ph reg = region ;
	// plot(reg, fill = 1 , wait = 1, value = 1);

int regH = reg(0,0);
int regT = reg(0,heartR*1.01);
	// cout << regH << endl;
	// cout << regT << endl;

// Introduce a control g such that 0 < g < 1 , g \in H1(T) , g = 0 in the torso

real gamma = 2.0;

V2h g = exp(-gamma * ((x-1)*(x-1) + y*y) ) * (reg == regH) ;

V2h vtrans = ischVtrans*(1-g) + healthyVtrans*g ;


plot(g,wait=1 , cmm = "control function g" , fill =1 );



// Build the conductivity tensor functions for the forward problem

V2h Mlhs = (Mi + Me )*g*(reg == regH) + (tMi + tMe )*(1-g)*(reg == regH) + M0*(reg == regT) ;
V2h Mrhs = Mi*g*(reg == regH) + tMi*(1-g)*(reg == regH) ;
	// plot(Mlhs, fill = 1 , wait = 1, value = 1 , nbiso = 20, cmm = "M lhs", dim = 3 );
	// plot(Mrhs, fill = 1 , wait = 1, value = 1 , nbiso = 20, cmm = "M rhs", dim = 3 );


// Build the conductivity tensor functions for the modified forward problem

V2h modMlhs = (Mi + Me )*g*g*(reg == regH) + (tMi + tMe )*(1-g*g)*(reg == regH) + M0*(reg == regT) ;
V2h modMrhs = Mi*g*g*(reg == regH) + tMi*(1-g*g)*(reg == regH) ;

// Plot the differences

V2h diffMrhs = abs(Mrhs - modMrhs) ;
V2h diffMlhs = abs(Mlhs - modMlhs) ;

	plot(diffMlhs, fill = 1 , wait = 1, value = 1 , nbiso = 20, cmm = "diff M lhs", dim = 3 );
	plot(diffMrhs, fill = 1 , wait = 1, value = 1 , nbiso = 20, cmm = "diff M rhs", dim = 3 );

// Setup the forward problem : variational formulations

varf a(uh,tuh) = int2d(Th)(Mlhs*(dx(uh)*dx(tuh) + dy(uh)*dy(tuh))) ;

varf amod(uh,tuh) = int2d(Th)(modMlhs*(dx(uh)*dx(tuh) + dy(uh)*dy(tuh))) ;

varf b(uh,tuh) = - int2d(Th)(Mrhs*( dx(tuh)*dx(vtrans) + dy(tuh)*dy(vtrans) ) ) ;

varf bmod(uh,tuh) = - int2d(Th)(modMrhs*( dx(tuh)*dx(vtrans) + dy(tuh)*dy(vtrans) ) ) ;

varf c(uh,tuh) = int2d(Th)(tuh) ;

// Setup the forward problem : matrices

matrix A = a(V2h,V2h) ;

matrix modA = amod(V2h,V2h);

real[int] C = c(0,V2h) ;

real[int] B = b(0,V2h) ;

real[int] modB = bmod(0,V2h);

matrix TOTAL = [ [ A ,  C ] ,
				 [ C' , 0 ] ];

matrix modTOTAL = [ [ modA ,  C ] ,
				 	[ C' , 0 ] ];

set(TOTAL, solver = UMFPACK) ;
set(modTOTAL, solver = UMFPACK) ;

// Solve the problem

Vh uh,tuh,moduh,modtuh;

real[int] rhs = [B,0];

cout <<"ndof : " << V2h.ndof << endl;
cout <<"size of rhs : " << rhs.n << endl;

real[int] sol(V2h.ndof + 1);

real[int] modsol(V2h.ndof + 1);

cout <<"size of solution : " << sol.n << endl;

sol= TOTAL^-1*rhs ;   // COMPLETAMENTE INSTABILE CON I P2 E P1b, MA STABILE CON P1!!!

modsol = modTOTAL^-1*rhs ;  

uh[] = sol(0 : V2h.ndof);

moduh[] = modsol(0 : V2h.ndof);


cout << "Lagrange multiplier : " << sol[V2h.ndof] << endl;

// Vh uh,tuh ;
problem ECGforward(uh,tuh) = 
	int2d(Th)(Mlhs*(dx(uh)*dx(tuh) + dy(uh)*dy(tuh)))
	+ int2d(Th)(Mrhs*( dx(tuh)*dx(vtrans) + dy(tuh)*dy(vtrans) ) )
	+ int2d(Th)(1e-8*uh*tuh)
	// + int2d(Th)(uh)*int2d(Th)(tuh) 
	;
// ECGforward;

// Vh aux = dx(vtrans);
// plot(aux,wait=1);
// aux = dy(vtrans);
// plot(aux,wait=1);



//Vh out = uh - int2d(Th)(uh) ;

plot(uh,wait=1,fill=1,nbiso = 20,dim=2 , cmm = "Solution for original problem");
plot(moduh,wait=1,fill=1,nbiso = 20,dim=2 , cmm = "Solution for modified problem");

plot(uh,wait=1,fill=1,nbiso = 20,dim=3 , cmm = "Solution for original problem");
plot(moduh,wait=1,fill=1,nbiso = 20,dim=3 , cmm = "Solution for modified problem");

V2h diffuh = abs(uh - moduh) ;

plot(diffuh,wait=1,fill=1,nbiso = 20,dim=3 , cmm = "Difference of the two solutions");

real integral = int2d(Th)(uh) ; 

cout <<"int(Th)(uh) : " << integral << endl;

real error = sqrt( int1d(Th,dT)(diffuh*diffuh) );

cout << "L2 norm of the output error : " << error << endl;


 // savevtk("forwardECG_g.vtk",Th,uh) ;

